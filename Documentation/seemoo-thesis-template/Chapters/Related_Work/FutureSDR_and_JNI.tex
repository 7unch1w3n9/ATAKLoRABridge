\subsection{FutureSDR and Java Native Interface (JNI)}

    However, systems such as LoRAgent and Meshtastic typically rely on proprietary communication stacks or dedicated hardware chipsets, which constrains flexibility and limits deeper customization. To fully leverage LoRa's capabilities and integrate it seamlessly into a wide range of mobile devices, a portable, efficient, and open-source Software -Defined Radio (SDR) framework for underlying signal processing is essential.

    Traditional SDR frameworks face challenges in platform adaptability, real-time performance, and runtime configuration, often falling short of the low-latency, cross-platform, and dynamically controllable requirements of real-world deployments. For instance, GNU Radio assigns each signal processing block, such as those for modulation, demodulation, and filtering, a dedicated thread and relies on buffered inter-thread communication for data transfer. While this model offers clarity and modularity, it incurs substantial thread-switching overhead, lacks support for fine-grained scheduling or heterogeneous hardware, and is generally ill-suited for embedded systems.

    In contrast, FutureSDR, introduced by Volz et al., employs a modular scheduling architecture that eliminates the resource overhead associated with thread-per-block designs. A centralized scheduler coordinates task execution based on data dependencies and resource availability, allowing a single thread to execute multiple blocks in sequence. This structure significantly reduces threading overhead and improves suitability for resource-constrained embedded devices. Moreover, FutureSDR incorporates a backend abstraction layer that enables signal processing modules to run across diverse computing platforms, including general-purpose CPUs, GPUs, and FPGAs, thereby delivering high portability and execution efficiency in heterogeneous or constrained environments.

    To integrate the Rust-based LoRa signal processing library, which is built on FutureSDR, into the ATAK plugin environment, a robust bridge between the Java application layer and native code is required. The Java Native Interface (JNI) serves as an ideal solution, being the standard native programming interface for the Java platform. A key strength of JNI is its binary compatibility: a compiled native library can execute consistently across different Java Virtual Machine implementations without platform-specific recompilation\cite{TODO}. This feature is particularly valuable for ATAK plugins targeting diverse Android devices.

    Architecturally, JNI uses an interface pointer table, which is a pointer to an array of function pointers, to access native methods. This design ensures a stable interface while accommodating varying VM implementations. In practice, Java methods are declared with the native keyword, with their implementations residing in dynamic shared libraries such as .so files. The VM resolves these symbols at runtime using a structured name-mapping convention.

    JNI also provides a complete type-mapping mechanism. Primitive Java types, for example int and double, are mapped to native equivalents such as jint and jdouble, while Java objects are handled via the jobject hierarchy. Memory management combines both local and global references. Local references are automatically reclaimed after native method execution, making them ideal for short-lived objects. Global references persist until explicitly released and are suitable for long-lived cross-context references. This dual model balances ease of use with safe memory practices.

    Additionally, JNI supports full exception handling, allowing native code to catch, check, or throw Java exceptions. The specification also enforces thread locality of JNI interface pointers, preventing their use across threads and ensuring thread-safe operation in concurrent environments\cite{TODO}. Together, these characteristics establish JNI as a reliable and efficient bridge between Java applications and native libraries, forming a solid technical basis for integrating ATAK plugins with FutureSDR flowgraphs.